import { useState, ChangeEvent } from "react"
import { getServerAddress } from "../services/localStorage"
import CustomFileList from "./custom-components/custom-file-list"
import useFetchFilesHook from "../hooks/fetchFilesHook"

const FileSender = () => {
    const [files, setFiles] = useState<File[]>([])
    const { activate } = useFetchFilesHook()

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        const inputFiles: FileList | null = event.target.files

        const newArray = Array.from(inputFiles as FileList).filter(newFile =>
            !files.some((existingFiles: File) => existingFiles.name === newFile.name)
        )

        event.target.value = ""

        setFiles(prevFiles => [...prevFiles , ...newArray])
    }

    const sendFiles = () => {
        const formData: FormData = new FormData()

        files.map((file: Blob, index) => {
            formData.append(`${ file.type }-${ index }`, file)
        })

        fetch(getServerAddress(`/send?username=${ localStorage.getItem("name") }`), {
            // This request doesn't include "content type" header, because the content type needs to be
            // generated by the browser, so the browser can include the multipart boundary and content type dynamically.
            // If the header is added the backend will return a response with "Bad Request" status.
            // Makes sense considering that Postman uses "multipart/form-data; boundary=<calculated when request is sent>" header.
            method: "POST",
            body: formData
        })
        .then(response => {
            if (response.ok) {
                setFiles([])

                // On success activate file fetching hook
                activate()

                console.log("File sent successfully")
            }

            else throw Error("Sending the file failed")
        })
        .catch(error => console.log("Error occured while sending the file", error))
    }

    return (
        <div id="file-sender-container">
            <input type="file" name="filepicker" multiple onChange={ handleChange } />
            <div>
                <button onClick={ sendFiles }>Send</button>
            </div>
            { files.length > 0 && (
                <div className="list-container">
                    <CustomFileList objectList={ files }
                        removeItem={ (filename: string) => {
                            const newList = files.filter(file => file.name !== filename)
                            setFiles(newList)
                        } }
                    />
                </div>
            ) }
        </div>
    )
}

export default FileSender