import { useState, useRef, RefObject, ChangeEvent, useEffect } from "react"
import LoadingButton from "@mui/lab/LoadingButton"
import { getServerAddress } from "../services/localStorage"
import UploaderFileList from "./component-parts/uploader-file-list"

interface Props {
    fileHook: {
        fetchFiles: boolean,
        activate: () => void,
        deactivate: () => void
    }
}

const FileSender = (props: Props) => {
    const [files, setFiles] = useState<File[]>([])
    const [dragging, setDragging] = useState(false)
    const [sending, setSending] = useState(false)
    const [isMobile, setIsMobile] = useState(false)
    const fileInputRef: RefObject<HTMLInputElement> = useRef(null)
    const { activate } = props.fileHook

    useEffect(() => {
        // Because this component has some elements that are only relevant to
        // desktop we need to check if user uses mobile device or not.
        const isMobileDevice = window.matchMedia("(max-width: 900px)").matches
        setIsMobile(isMobileDevice)
    }, [])

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        const inputFiles: FileList | null = event.target.files
        createNewFileArray(inputFiles)
        event.target.value = ""
    }
    
    const createNewFileArray = (inputFiles: FileList | null) => {
        const newArray = Array.from(inputFiles as FileList).filter(newFile =>
            !files.some((existingFiles: File) => existingFiles.name === newFile.name)
        )

        setFiles(prevFiles => [...prevFiles , ...newArray])
    }

    const sendFiles = () => {
        setSending(true)

        const formData: FormData = new FormData()

        files.map((file: Blob, index) => {
            formData.append(`${ file.type }-${ index }`, file)
        })

        fetch(getServerAddress(`/send?username=${ localStorage.getItem("name") }`), {
            // This request doesn't include "content type" header, because the content type needs to be
            // generated by the browser, so the browser can include the multipart boundary and content type dynamically.
            // If the header is added the backend will return a response with "Bad Request" status.
            // Makes sense considering that Postman uses "multipart/form-data; boundary=<calculated when request is sent>" header.
            method: "POST",
            body: formData
        })
            .then(response => {
                if (response.ok) {
                    setFiles([])

                    // On success activate file fetching hook
                    activate()

                    console.log("File sent successfully")
                    setSending(false)
                }

                else {
                    setSending(false)
                    throw Error("Sending the file failed")
                }
            })
            .catch(error => {
                console.log("Error occured while sending the file", error)
                setSending(false)
            })

    }

    const onDragEnter = () => {
        setDragging(true)
    }

    const onDragExit = () => {
        setDragging(false)
    }

    const onDrop = (event: React.DragEvent) => {
        event.preventDefault()
        const fileList: FileList | null = event.dataTransfer.files

        createNewFileArray(fileList)
        setDragging(false)
    }

    const activateFilepickerOnClick = () => {
        // A lot cleaner than the label trick to click a hidden input element
        if (fileInputRef.current) {
            fileInputRef.current.click()
        }
    }

    return (
        <>
        <div className={`file-sender drag-highlight${ (dragging) ? " show-highlight" : "" }`} 
            onDragEnter={ onDragEnter } onDragExit={ onDragExit } onDrop={ onDrop }>
            <div className={`custom-file-input flex column`}>
                { (!dragging) && (
                    <>
                    { (!isMobile) && (
                        <>
                        <h3>Drop files here</h3>
                        <span>or</span>
                        </>
                    ) }
                    <div className="button-container">
                        <button className="minimal-width" onClick={ activateFilepickerOnClick } disabled={ sending }>
                            { (!isMobile) ? "Press here" : "Add files" }
                        </button>
                    </div>
                    <input ref={ fileInputRef } className="hidden" type="file" id="filepicker" multiple onChange={ handleChange } />
                    </>
                ) }
            </div>
        </div>

        <div className="file-sender-list container">
            { (files.length > 0) && (
                <>
                <h3>Files selected: { files.length }</h3>
                <div className="list-container">
                    <UploaderFileList fileList={ files } disableButton={ sending }
                        removeItem={ (filename: string) => {
                            const newList = files.filter(file => file.name !== filename)
                            setFiles(newList)
                        } }
                        />
                </div>
                </>
            ) }
        </div>
        { (files.length > 0) && 
            <LoadingButton onClick={ sendFiles } size="medium" variant="outlined" color="primary"
                loading={ sending } disabled={ sending }>
                    Upload
            </LoadingButton>
        }
        </>
    )
}

export default FileSender