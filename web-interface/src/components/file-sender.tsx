import { useState, useRef, ChangeEvent, useEffect } from "react"
import LoadingButton from "@mui/lab/LoadingButton"
import { getServerAddress } from "../services/localStorage"
import CustomFileList from "./custom-components/custom-file-list"

interface Props {
    fileHook: {
        fetchFiles: boolean,
        activate: () => void,
        deactivate: () => void
    }
}

const FileSender = (props: Props) => {
    const [files, setFiles] = useState<File[]>([])
    const [dragging, setDragging] = useState(false)
    const [sending, setSending] = useState(false)
    const [isMobile, setIsMobile] = useState(false)
    const fileInputRef = useRef(null)
    const { activate } = props.fileHook

    useEffect(() => {
        // Because this component has some elements that are only relevant to
        // desktop we need to check if user uses mobile device or not.
        const isMobileDevice = window.matchMedia("(max-width: 900px)").matches
        setIsMobile(isMobileDevice)
    }, [])

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        const inputFiles: FileList | null = event.target.files
        createNewFileArray(inputFiles)
        event.target.value = ""
    }
    
    const createNewFileArray = (inputFiles: FileList | null) => {
        const newArray = Array.from(inputFiles as FileList).filter(newFile =>
            !files.some((existingFiles: File) => existingFiles.name === newFile.name)
        )

        setFiles(prevFiles => [...prevFiles , ...newArray])
    }

    const sendFiles = () => {
        setSending(true)

        const formData: FormData = new FormData()

        files.map((file: Blob, index) => {
            formData.append(`${ file.type }-${ index }`, file)
        })

        fetch(getServerAddress(`/send?username=${ localStorage.getItem("name") }`), {
            // This request doesn't include "content type" header, because the content type needs to be
            // generated by the browser, so the browser can include the multipart boundary and content type dynamically.
            // If the header is added the backend will return a response with "Bad Request" status.
            // Makes sense considering that Postman uses "multipart/form-data; boundary=<calculated when request is sent>" header.
            method: "POST",
            body: formData
        })
            .then(response => {
                if (response.ok) {
                    setFiles([])

                    // On success activate file fetching hook
                    activate()

                    console.log("File sent successfully")
                    setSending(false)
                }

                else {
                    setSending(false)
                    throw Error("Sending the file failed")
                }
            })
            .catch(error => {
                console.log("Error occured while sending the file", error)
                setSending(false)
            })

    }

    const onDragEnter = () => {
        setDragging(true)
    }

    const onDragExit = () => {
        setDragging(false)
    }

    const onDrop = (event: React.DragEvent) => {
        event.preventDefault()
        const fileList: FileList | null = event.dataTransfer.files

        createNewFileArray(fileList)
        setDragging(false)
    }

    const activateFilepickerOnClick = () => {
        // A lot cleaner than the label trick to click a hidden input element
        if (fileInputRef.current) {
            fileInputRef.current.click()
        }
    }

    return (
        <div className={`container file-sender drag-highlight ${ (dragging) && " show-highlight" }`} 
            onDragEnter={ onDragEnter } onDragExit={ onDragExit } onDrop={ onDrop }>
            <div className={`custom-file-input flex column centerplacehol${ (dragging) ? " non-targetable" : "" }der`}>
                { (!isMobile)
                ? (
                    <>
                    <h3 className={`${ (dragging) ? "non-targetable" : "" }`}>Drop files here</h3>
                    <span  className={`${ (dragging) ? "non-targetable" : "" }`}>or</span>
                    <div className={`button-containerplacehol${ (dragging) ? " non-targetable" : "" }der`}>
                        <button type="button" className={`minimal-width${ (dragging) ? " non-targetable" : "" }`} 
                            onClick={ activateFilepickerOnClick } disabled={ sending }>
                            Press here
                        </button>
                    </div>
                    <input ref={ fileInputRef } className="hidden" type="file" id="filepicker" multiple onChange={ handleChange } />
                    </>
                )
                : (
                    <div className={`button-containerplacehol${ (dragging) ? " non-targetable" : "" }der`}>
                        <button type="button" className={`minimal-width${ (dragging) ? " non-targetable" : "" }`} 
                            onClick={ activateFilepickerOnClick } disabled={ sending }>
                            Add files
                        </button>
                    </div>
                ) }
            </div>

            { (files.length > 0) && (
                <>
                <h3>Files selected: { files.length }</h3>
                <div className="list-container">
                    <CustomFileList objectList={ files }
                        removeItem={ (filename: string) => {
                            const newList = files.filter(file => file.name !== filename)
                            setFiles(newList)
                        } }
                        />
                </div>
                </>
            ) }
            { (files.length > 0) && 
                <LoadingButton onClick={ sendFiles } size="medium" variant="outlined" color="primary"
                    loading={ sending } disabled={ sending }>
                        Upload
                </LoadingButton>
            }
        </div>
    )
}

export default FileSender