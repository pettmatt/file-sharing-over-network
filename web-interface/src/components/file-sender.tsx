import { useState, useRef, ChangeEvent } from "react"
import LoadingButton from "@mui/lab/LoadingButton"
import { getServerAddress } from "../services/localStorage"
import CustomFileList from "./custom-components/custom-file-list"
import useFetchFilesHook from "../hooks/fetchFilesHook"

const FileSender = () => {
    const [files, setFiles] = useState<File[]>([])
    const [dragging, setDragging] = useState(false)
    const [sending, setSending] = useState(false)
    const fileInputRef = useRef(null)
    const { activate } = useFetchFilesHook()

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        const inputFiles: FileList | null = event.target.files
        createNewFileArray(inputFiles)
        event.target.value = ""
    }
    
    const createNewFileArray = (inputFiles: FileList | null) => {
        const newArray = Array.from(inputFiles as FileList).filter(newFile =>
            !files.some((existingFiles: File) => existingFiles.name === newFile.name)
        )

        setFiles(prevFiles => [...prevFiles , ...newArray])
    }

    const sendFiles = () => {
        setSending(true)

        const formData: FormData = new FormData()

        files.map((file: Blob, index) => {
            formData.append(`${ file.type }-${ index }`, file)
        })

        fetch(getServerAddress(`/send?username=${ localStorage.getItem("name") }`), {
            // This request doesn't include "content type" header, because the content type needs to be
            // generated by the browser, so the browser can include the multipart boundary and content type dynamically.
            // If the header is added the backend will return a response with "Bad Request" status.
            // Makes sense considering that Postman uses "multipart/form-data; boundary=<calculated when request is sent>" header.
            method: "POST",
            body: formData
        })
        .then(response => {
            if (response.ok) {
                setFiles([])

                // On success activate file fetching hook
                activate()

                console.log("File sent successfully")
                setSending(false)
            }

            else {
                setSending(false)
                throw Error("Sending the file failed")
            }
        })
        .catch(error => {
            console.log("Error occured while sending the file", error)
            setSending(false)
        })

    }

    const onDragEnter = () => {
        setDragging(true)
    }
    
    const onDragExit = () => {
        setDragging(false)
    }

    const onDrop = (event: React.DragEvent) => {
        event.preventDefault()
        const fileList: FileList | null = event.dataTransfer.files

        createNewFileArray(fileList)
        setDragging(false)
    }

    const activateFilepickerOnClick = () => {
        // A lot cleaner than the label trick to click a hidden input element
        if (fileInputRef.current) {
            fileInputRef.current.click()
        }
    }

    return (
        <div className={`container file-sender drag-highlight ${ (dragging) && "show-highlight" }`} 
            onDragEnter={ onDragEnter } onDragExit={ onDragExit } onDrop={ onDrop }>
            <div className="custom-file-input flex column center">
                <h3>Drop files here</h3>
                <span>or</span>
                <div className="button-container">
                    <button type="button" className="minimal-width" onClick={ activateFilepickerOnClick } disabled={ sending }>
                        Press here
                    </button>
                </div>
                <input ref={ fileInputRef } className="hidden" type="file" id="filepicker" multiple onChange={ handleChange } />
            </div>

            { (files.length > 0) && (
                <>
                <h3>Files selected: { files.length }</h3>
                <div className="list-container">
                    <CustomFileList objectList={ files }
                        removeItem={ (filename: string) => {
                            const newList = files.filter(file => file.name !== filename)
                            setFiles(newList)
                        } }
                        />
                </div>
                </>
            ) }
            { (files.length > 0) && 
                <LoadingButton onClick={ sendFiles } size="medium" variant="outlined" color="primary"
                    loading={ sending } disabled={ sending } loadingPosition="start">
                        Upload
                </LoadingButton>
            }
        </div>
    )
}

export default FileSender