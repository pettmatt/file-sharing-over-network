import { useState, ChangeEvent } from "react"
import { getServerAddress } from "../services/localStorage"
import CustomFileList from "./custom-components/custom-file-list"
import useFetchFilesHook from "../hooks/fetchFilesHook"

const FileSender = () => {
    const [files, setFiles] = useState<File[]>([])
    const [dragging, setDragging] = useState(false)
    const { activate } = useFetchFilesHook()

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        const inputFiles: FileList | null = event.target.files
        createNewFileArray(inputFiles)
        event.target.value = ""
    }
    
    const createNewFileArray = (inputFiles: FileList | null) => {
        const newArray = Array.from(inputFiles as FileList).filter(newFile =>
            !files.some((existingFiles: File) => existingFiles.name === newFile.name)
        )

        setFiles(prevFiles => [...prevFiles , ...newArray])
    }

    const sendFiles = () => {
        const formData: FormData = new FormData()

        files.map((file: Blob, index) => {
            formData.append(`${ file.type }-${ index }`, file)
        })

        fetch(getServerAddress(`/send?username=${ localStorage.getItem("name") }`), {
            // This request doesn't include "content type" header, because the content type needs to be
            // generated by the browser, so the browser can include the multipart boundary and content type dynamically.
            // If the header is added the backend will return a response with "Bad Request" status.
            // Makes sense considering that Postman uses "multipart/form-data; boundary=<calculated when request is sent>" header.
            method: "POST",
            body: formData
        })
        .then(response => {
            if (response.ok) {
                setFiles([])

                // On success activate file fetching hook
                activate()

                console.log("File sent successfully")
            }

            else throw Error("Sending the file failed")
        })
        .catch(error => console.log("Error occured while sending the file", error))
    }

    const onDragEnter = () => {
        setDragging(true)
    }
    
    const onDragExit = () => {
        setDragging(false)
    }

    const onDrop = (event: React.DragEvent) => {
        event.preventDefault()
        const fileList: FileList | null = event.dataTransfer.files

        createNewFileArray(fileList)
        setDragging(false)
    }

    return (
        <div className={`container file-sender drag-highlight ${ (dragging) && "show-highlight" }`} 
            onDragEnter={ onDragEnter } onDragExit={ onDragExit } onDrop={ onDrop }>
            <div className="custom-file-input flex column center">
                <h3>Drop files here</h3>
                <span>or</span>
                <label htmlFor="filepicker">
                    <button type="button" className="minimal-width">Press here</button>
                </label>
                <input className="hidden" type="file" id="filepicker" multiple onChange={ handleChange } />
            </div>

            { (files.length > 0) && (
                <>
                <h3>Files selected: { files.length }</h3>
                <div className="list-container">
                    <CustomFileList objectList={ files }
                        removeItem={ (filename: string) => {
                            const newList = files.filter(file => file.name !== filename)
                            setFiles(newList)
                        } }
                        />
                </div>
                </>
            ) }
            { (files.length > 0) && <button onClick={ sendFiles }>Send files</button> }
        </div>
    )
}

export default FileSender