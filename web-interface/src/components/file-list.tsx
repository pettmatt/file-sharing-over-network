import { useState, useEffect, ChangeEvent } from "react"
import { List, ListItem, ListItemText} from "@mui/material"
// import { styled, Button, SvgIcon } from "@mui/joy"

interface Props {
    devices: object
}

interface CustomFile {
    name: string,
    type: string,
    size: number
}

const FileList = (props: Props) => {
    console.log(props)
    const [files, setFiles] = useState<File[]>([])
    const [localFiles, setLocalFiles] = useState([])

    useEffect(() => {
        getLocalFiles()
    }, [])

    const handleChange = (event: ChangeEvent<HTMLInputElement>) => {
        const inputFiles: FileList | null = event.target.files

        const newArray = Array.from(inputFiles as FileList).filter(newFile =>
            !files.some((existingFiles: File) => existingFiles.name === newFile.name)
        )

        event.target.value = ""

        setFiles(prevFiles => [...prevFiles , ...newArray])
    }

    const sendFiles = () => {
        const formData: FormData = new FormData()

        files.map((file: Blob, index) => {
            formData.append(`${ file.type }-${ index }`, file)
        })

        fetch("http://localhost:7878/send-file", {
            // This request doesn't include "content type" header, because the content type needs to be
            // generated by the browser, so the browser can include the multipart boundary and content type dynamically.
            // If the header is added the backend will return a response with "Bad Request" status.
            // Makes sense considering that Postman uses "multipart/form-data; boundary=<calculated when request is sent>" header.
            method: "POST",
            body: formData
        })
        .then(response => {
            if (response.ok) {
                getLocalFiles()
                console.log("File sent successfully")
            }

            else console.log("Sending the file failed")
        })
        .catch(error => console.log("Error occured while sending the file", error))
    }

    const getLocalFiles = () => {
        fetch("http://localhost:7878/local-files")
        .then(response => {
            if (response.ok) {
                response.json()
                .then(content => setLocalFiles(content.files))
                .catch(error => console.log("Failed to fetch local files", error))
            }

            else console.log("Fetching local files failed")
        })
        .catch(error => console.log("Error occured while fetching local files", error))
    }

    return (
        <>
        <div className="section-container">
            <div className="notification-container">
                {
                    (localFiles.length === 0)
                    ? <h3>No files have been added</h3>
                    : (
                        <>
                        <h3>Your files ({ localFiles.length })</h3>
                        <CustomLocalFileList fileList={ localFiles }
                            setFiles={ setLocalFiles }
                            removeFile={ (filename: string) => {
                                fetch(`http://localhost:7878/local-file?file_name=${ filename }`, {
                                    method: "DELETE"
                                })
                                .then(response => {
                                    if (response.ok) {
                                        console.log("File removed successfully")
                                        getLocalFiles()
                                    }

                                    else console.log(`Removing '${ filename }' file failed`)
                                })
                                .catch(error => console.log("Error occured while removing a file:", error))
                            } }
                            downloadFile={ (filename: string) => {
                                fetch(`http://localhost:7878/download-file?file_name=${ filename }`)
                                    .then((response: Response) => {
                                        if (response.ok && response.body !== null) {
                                            downloadFile(response.body, filename)
                                        }

                                        else console.log("Download failed")
                                    })
                                    .catch(error => console.log("Error", error))
                            } }
                        />
                        </>
                    )
                }
                <input type="file" name="filepicker" multiple onChange={ handleChange } />
                <div>
                    <button onClick={ sendFiles }>Send</button>
                </div>
                { files.length > 0 && (
                    <div className="list-container">
                        <CustomUploadList fileList={ files } 
                            setFiles={ setFiles }
                            removeFile={ (filename: string) => {
                                const newList = files.filter(file => file.name !== filename)
                                setFiles(newList)
                            } }
                        />
                    </div>
                ) }
            </div>
        </div>
        </>
    )
}

const downloadFile = async (stream: ReadableStream, filename: string) => {
    try {
        const rs: ReadableStream = stream
        const blob: Blob = await streamToBlob(rs)

        const blobURL = URL.createObjectURL(blob)

        const downloadLink = document.createElement("a")
        downloadLink.href = blobURL
        downloadLink.download = filename
        downloadLink.style.display = "none"

        console.log("Starting download step")
        document.body.appendChild(downloadLink)
        downloadLink.click()

        document.body.removeChild(downloadLink)
        URL.revokeObjectURL(blobURL)
    }
    catch (error) {
        console.log("Error occured while processing stream", error)
    }
}

const streamToBlob = async (stream: ReadableStream) => {
    const reader = stream.getReader()
    const chunks = []

    console.log("Processing stream to blob")
    const condition: boolean = true

    while (condition) {
        const { value, done } = await reader.read()
        if (done) break

        chunks.push(value)
    }

    console.log("Blob is ready")

    return new Blob(chunks)
}

type customFunction = (param: string) => void | string

interface ListProps {
    fileList: Array<object>,
    setFiles: React.Dispatch<React.SetStateAction<never[]>> | React.Dispatch<React.SetStateAction<File[]>>,
    removeFile: customFunction,
    downloadFile?: customFunction
}

const CustomUploadList = (props: ListProps) => {

    const formatBytes = (bytes: number, decimals = 2): string => {
        if (bytes === 0) return '0 Bytes'

        const k = 1024
        const dm = (decimals < 0) ? 0 : decimals
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB']

        const i = Math.floor(Math.log(bytes) / Math.log(k))

        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + " " + sizes[i]
    }

    const itemList = props.fileList.map((item, index) => {
        const file = item as CustomFile

        return(
            <ListItem disablePadding key={ index }>
                <button onClick={ () => props.removeFile(file.name) }>Remove</button>
                <ListItemText primary={ `${ file.name } ${ file.type } ${ formatBytes(file.size) }` } />
            </ListItem>
        )
    })

    return (
        <List>
            { itemList }
        </List>
    )
}

const CustomLocalFileList = (props: ListProps) => {
    const itemList = props.fileList.map((item, index) => {
        const filename = JSON.stringify(item)

        return (
            <ListItem disablePadding key={ index }>
                <button onClick={ () => props.removeFile(filename) }>Remove</button>
                <button onClick={ () => (props.downloadFile) && props.downloadFile(filename) }>Download</button>
                <ListItemText primary={ `${ item }` } />
            </ListItem>
        )
    })

    return (
        <List>
            { itemList }
        </List>
    )
}

export default FileList
